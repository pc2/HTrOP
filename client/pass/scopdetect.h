//    Copyright (c) 2019 University of Paderborn 
//                         (Gavin Vaz <gavin.vaz@uni-paderborn.de>,
//                          Heinrich Riebler <heinrich.riebler@uni-paderborn.de>)

//    Permission is hereby granted, free of charge, to any person obtaining a copy
//    of this software and associated documentation files (the "Software"), to deal
//    in the Software without restriction, including without limitation the rights
//    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//    copies of the Software, and to permit persons to whom the Software is
//    furnished to do so, subject to the following conditions:

//    The above copyright notice and this permission notice shall be included in
//    all copies or substantial portions of the Software.

//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//    THE SOFTWARE.

#ifndef SCOPDETECT_H
#define SCOPDETECT_H

#include "llvm/Pass.h"
#include "llvm/PassAnalysisSupport.h"
#if LLVM_VERSION == 3 && LLVM_MINOR_VERSION < 5
#include "llvm/InstVisitor.h"
#else
#include "llvm/IR/InstVisitor.h"
#endif
#include "llvm/Analysis/ScalarEvolution.h"
#include "llvm/Analysis/ScalarEvolutionExpressions.h"
#include "llvm/Analysis/LoopInfo.h"

#include "polly/ScopPass.h"
#include "polly/ScopInfo.h"

#include "isl/set.h"

#include "../../common/sharedStructCompileRuntime.h"

#include <list>
#include <iostream>
#include <string>
#include <vector>
#include <sstream>
#include <utility>

using namespace llvm;

namespace htrop {

    // - i0.min "0" .
    // - i0.max "-1 + rows" .
    // - i1.min "0" .
    // - i1.max "-1 + cols" .
    struct InternArrayDimensionInfo {
        // Name of the dimension.
        std::string nameStr = "";
        unsigned long long minValue = 0;
        unsigned long long maxValue = 0;
         std::string minValueStr = "0";
         std::string maxValueStr = "0";
    };

    class ScopDetect:public polly::ScopPass {
 public:
        static char ID;
        // Debug flag to enable hand tuning, if automated detection is not sufficient.
        //   Call stub for automated code tuner.
        static int debug_hand_tune_pos;

         ScopDetect():ScopPass(ID) {
        } ScopDetect(std::vector<int> maxScopDepth):ScopPass(ID) {
            ScopDetect::maxScopDepth = maxScopDepth;
        } bool runOnScop(polly::Scop & S) override;
        void getAnalysisUsage(AnalysisUsage & AU) const override;

        Function *getScopFunction();
        Function *getScopFunctionParent();

        std::vector < ScopFnArg * >getScopFuncitonArgs();
        std::vector < ScopLoopInfo * >getScopLoopInfo();
        bool containsScop();
        void clear();

        int getMaxCodegenLoopDepth();
        
 private:

        Function * scopFuncton;
        Function *scopFunctonParent;
        bool scopFound = false;

        std::vector<int> maxScopDepth;

        // This is used for the kernel function
        std::vector < ScopFnArg * >scopFunctonArgs;

        //Used for the kernels (chaining)
        std::vector < ScopLoopInfo * >scopLoopInfo;

        /**
         * @brief This function takes the string generated by getMinMaxStringFromAliasGroups() and 
         *        updates the ScopFnArg with MIN and MAX values for each dimension.
         * 
         * @param kernelArgs the arrays required for the computation as ScopFnArg vector.
         * @param min_or_max the MIN or MAX string.
         * @param loopDepth the depth of the loop nest. Assumption is that it reflects the dimensions of the arrays.
         * @param ILI ScopLoopInfo helps with the upper bound values of each loop ("N" or "M")
         * @param min switch for MIN or MAX terms.
         * @return void
         */
        void resolveMinMaxString(std::vector < ScopFnArg * >*kernelArgs, std::string min_or_max, unsigned int loopDepth, ScopLoopInfo * ILI, bool min);

        std::vector < InternArrayDimensionInfo > resolveDomainString(std::string domainStr);

        // ### Set DataTransferType
        //           currently | UNKNOWN | IN    | OUT    | IN_OUT  | TMP
        //       statement     |
        //       ---------------------------------------------------------
        //       READ              IN     IN       IN_OUT   IN_OUT    IN
        //       MUST_WRITE        OUT    IN_OUT    OUT     IN_OUT    OUT
        //       MAY_WRITE         OUT    IN_OUT    OUT     IN_OUT    OUT
        void setDataTransferType(polly::MemoryAccess * MA, ScopFnArg * kernel_argument);
        
        int max_codegen_loop_depth = 0;
    };

    llvm::Pass * createScopDetectPass(std::vector<int> maxScopDepth);
}

#endif                          // SCOPDETECT_H
